function [ secs, keyCode ] = rGraphicsDraw_P300(duration, dont_clear, specific_keys, varargin)% function event_ = rGraphicsDraw(duration, dont_clear)%% Calls class-specific draw routine for all the%   drawable objects in ROOT_STRUCT, then draws by%   flipping the screen buffers (once)%% Arguments:%   duration        ... in ms, time to loop draw commands%   dont_clear      ... flag sent to Screen('Flip', ...) default false%   specific_keys   ... if defined, break only occurs when these keys are pressed%   clear_rand_matrix.. if defined, re-create random matrices (note: takes time)%   reversals       ... Nx4 array specifying details convolution, columns%                       defined as follows:%                           (1) time onset (ms)%                           (2) time offset (ms)%                           (3) direction: 1=left, 2=right%                       For each direction, 1 is full motion in that direction.%                       As an example, [100 1] has leftward motion. Additional %                       rows can be added to enable additional motion changes %                       at specified timepoints.%   %% Returns:%   event_      ... a keyboard event that terminated drawing%                   event = [keyCode, value, time];% Copyright 2005 by Joshua I. Gold%   University of Pennsylvaniaglobal ROOT_STRUCTevent_ = [];% EK - make daq awareglobal daq% EK - reduce calls to memory, use persistenceif length(varargin) == 2    reversals           = cell2mat(varargin(1));    clear_rand_matrix   = cell2mat(varargin(2));elseif length(varargin) == 1    reversals           = cell2mat(varargin(1));    clear_rand_matrix   = 0;elseif ~isempty(varargin)    % too many arguments!    error('Too many arguments provided.');else    reversals           = [inf inf 0];    clear_rand_matrix   = 0;end    if clear_rand_matrix    clear randImg1 randImg2endpersistent randImg1 randImg2 l_frame r_frame% EK - Create gabor filtersif isempty(randImg1) || isempty(randImg2)    % put up "Men Working" notice    Screen('TextSize', ROOT_STRUCT.windowNumber, 24);    Screen('DrawText', ROOT_STRUCT.windowNumber, 'Constructing noise matrices, please wait...', 10, 10, 255);    Screen('Flip', ROOT_STRUCT.windowNumber);    % define some noise, limit to within 2 sd    matSize = 50;    rand_matrix1 = randn(matSize);    rand_matrix2 = randn(matSize);    % tested - requires only betwee 3-5 iterations to complete each loop    while sum( sum( rand_matrix1 >= 2 ) ) ~= 0        rand_matrix1( rand_matrix1 >= 2 ) = randn([ 1 length( find( rand_matrix1 >= 2 ) ) ]);    end    while sum( sum( rand_matrix2 >= 2 ) ) ~= 0        rand_matrix2( rand_matrix2 >= 2 ) = randn([ 1 length( find( rand_matrix2 >= 2 ) ) ]);    end    % generate gaussian mesh    [Cx Cy] = meshgrid(-3:0.3:3);    G = 1/sqrt(2*pi)*exp(-((Cx.^2/2)+(Cy.^2/2)));    G = G/max(max(G));    % generate gabor plots, scale them    Gd  = diff(G,1,2);    Gdd = diff(Gd,1,2);    Gd  = Gd/max(max(Gd));    Gdd = Gdd/min(min(Gdd));    % fix matrix sizes to be equal    Gd  = Gd (1:size(Gd ,1)-2,1:size(Gd,2)-1);    Gdd = Gdd(2:size(Gdd,1)-1,:);    % combine plots using eq 1 of paper, convolve with noise    t = linspace( pi/180, 2*pi, 180 );    len_t = length(t);    img = zeros([len_t, size(Gdd)]);    for n=1:len_t        img(n,:,:) = cos(t(n))*Gdd + sin(t(n))*Gd;    end    % convolve with random noise    randImg1 = zeros([len_t size(rand_matrix1)]);    randImg2 = randImg1;    for n=1:len_t        % motion in two directions; rand_matrix1 goes left, rand_matrix2 right        img1 = conv2( rand_matrix1, squeeze(img(n,:,:)), 'same' );        img2 = conv2( rand_matrix2, squeeze(img(len_t+1-n,:,:)), 'same' );        randImg1(n,:,:) = img1;        randImg2(n,:,:) = img2;    end        % initialize the frame count    l_frame = 1;    r_frame = 1;endif nargin < 1    duration = 0;else    % clear old keyboard values for event checking    ROOT_STRUCT.dXkbHID = reset(ROOT_STRUCT.dXkbHID);endif nargin < 2 || isempty(dont_clear)    dont_clear = 0;endif ROOT_STRUCT.screenMode == 2        %   drawFlag = 1 ... draw, clear buffer    %   drawFlag = 2 ... draw, do NOT clear buffer    %   drawFlag = 3 ... draw ONCE, clear buffer    %   drawFlag = 4 ... draw ONCE, do NOT clear buffer    df = 4 - 2*(duration > 0) - ~dont_clear;    msg = sprintf('draw_flag=%d;', df);endif nargin < 1 || duration == 0    % flip buffers once    switch ROOT_STRUCT.screenMode        case 0            % debug mode, do nothing        case 1            % loop through the drawables            for dr = ROOT_STRUCT.methods.draw                % call class-specific draw                ROOT_STRUCT.(dr{:}) = draw(ROOT_STRUCT.(dr{:}));            end            % send done drawing command .. sometimes optimizes            Screen('DrawingFinished', ROOT_STRUCT.windowNumber, dont_clear);            % flip the buffers            Screen('Flip', ROOT_STRUCT.windowNumber, 0, dont_clear);        case 2            % remote mode            sendMsgH(msg);    endelse    % flip buffers for duration    start_time = GetSecs;    % convert duration to seconds    duration = duration/1000;    % if remote, send command first    if ROOT_STRUCT.screenMode == 2        sendMsgH(msg);    end    % loop until done    currTime = GetSecs - start_time;    while currTime < duration        if ROOT_STRUCT.screenMode == 1                        % EK - draw the background                        % find direction of each image            r_frame_dir = 1;  % 1 = full right, -1 = full left            l_frame_dir = 1;  % 1 = full left,  -1 = full right            reversal_index = currTime > reversals(:,1) & currTime < reversals(:,2);            if reversal_index > 0                if size(reversal_index) > 1                    error('Reversal matrix contains overlapping time windows.');                elseif reversals(reversal_index,3) == 1                    r_frame_dir = -1;                elseif reversals(reversal_index,3) == 2                    l_frame_dir = -1;                else                    error('Reversal direction entry should only be 1 (left) or 2 (right).');                end            end                        img = squeeze( randImg1( l_frame, :, : ) ) + squeeze( randImg2( r_frame, :, : ) );            l_frame = l_frame + l_frame_dir;            r_frame = r_frame + r_frame_dir;                        % reset if overflow            if l_frame == 0                l_frame = length(randImg1);            elseif l_frame == length(randImg1)+1;                l_frame = 1;            end                            if r_frame == 0                r_frame = length(randImg1);            elseif r_frame == length(randImg1)+1;                r_frame = 1;            end                        noiseScreen = Screen('MakeTexture', ROOT_STRUCT.windowNumber, img);            Screen('DrawTexture', ROOT_STRUCT.windowNumber, noiseScreen)            % loop through the drawables            % EK - Added if block to allow running of rGraphicsDraw (without            %      defined drawables) to pre-construct noise matrices.            if ismethod(ROOT_STRUCT.methods, 'draw')                for dr = ROOT_STRUCT.methods.draw                    % call class-specific draw                    ROOT_STRUCT.(dr{:}) = draw(ROOT_STRUCT.(dr{:}));                end            end                            % send done drawing command .. sometimes optimizes            Screen('DrawingFinished', ROOT_STRUCT.windowNumber, dont_clear);            % flip the buffers            Screen('Flip', ROOT_STRUCT.windowNumber, 0, dont_clear);        else            % pause briefly            WaitSecs(0.002);        end                % if in USB device, we're using parallel computing, check for responses in /tmp/resp        if daq ~= -1                        keyIsDown = 0;            keyCode = zeros(1,256);  % preallocate these variables            resp = csvread( '/tmp/resp.txt' );            if ~isempty( resp )                                keyIsDown = resp(1);                secs      = resp(2);                keyCode(resp(3)) = 1;                                % clear the file                ptr = fopen( '/tmp/resp.txt', 'w' );                fclose( ptr );                                % check against specific keys                keynum = find(keyCode);                if keyIsDown && ~isempty( find( specific_keys == keynum, 1 ) )                    break;                end            end        % it not using USB device, just query the keyboard        else            [keyIsDown, secs, keyCode] = KbCheckMulti;            keynum = find(keyCode);            if keyIsDown && ~isempty( find( specific_keys == keynum, 1 ) )                break;            end        end    end    % if remote, send done command    if ROOT_STRUCT.screenMode == 2        sendMsgH('draw_flag=0;');    endend